<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Tarot Reader by meobeo</title>
    <meta property="og:title"           content="Tarot Reader"/>
    <meta property="og:description"     content="A cute Tarot reading website" />
    <meta property="og:image"           content="https://firebasestorage.googleapis.com/v0/b/saveimage-5dfc7.appspot.com/o/tarot.png?alt=media&token=be6c786e-d35d-408d-85de-a4954df20f35" />
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/music.css">
    <link rel="stylesheet" href="css/button-get-new-card.css">
    <link rel="stylesheet" href="css/result.css">
    <link rel="stylesheet" href="css/donate.css">
    <link rel="stylesheet" href="css/wizard.css">
    <link rel="stylesheet" href="css/sakura.css">
    <script src="js/sakura.js"></script>
    <link rel="icon" type="image/png" href="img/icon/hat-wizard-solid.svg">
</head>

<body>
    <img id="music" src="img/muted.png" onclick="toggleImageBorderAndMusic()">
    <audio id="backgroundMusic" loop>
        <source src="sound/music.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>
    <button type="button" class="btn" id="wizardButton" onclick="displayWizard()">
        <strong>Bốc bài</strong>
        <div id="container-stars">
            <div id="stars"></div>
        </div>
        <div id="glow">
            <div class="circle"></div>
            <div class="circle"></div>
        </div>
    </button>
    <div id="wizard">
        <div id="talk">
            <select id="thinking">
                <option value="" disabled selected hidden>Bạn đang nghĩ gì?</option>
                <option value="love">Tình yêu</option>
                <option value="career">Sự nghiệp</option>
                <option value="health">Sức khoẻ</option>
                <option value="other">Khác</option>
            </select>
            <button id="submit" onclick="displayTarotCard()">OK</button>
        </div>
    </div>
    <canvas id="sakura"></canvas>
    <div class="btnbg">
    </div>
    <div id="tutorial">
        <span style="font-weight: 600; font-size: 20px;">Chào mừng bạn đến với Tarot Reader của meobeo. Cảm ơn các bạn đã ghé thăm trang web của mình!</span><br><br><br>
        <span>Dưới đây là những hướng dẫn cơ bản để bạn có thể tận hưởng trải nghiệm xem bài Tarot một cách dễ dàng:<br><br>
            <b>Bước 1: Chuẩn bị</b><br><br>
            Trước tiên, hãy chọn một không gian yên tĩnh và tạo điều kiện thuận lợi cho sự tập trung. Nếu có câu hỏi cụ thể hoặc vấn đề bạn muốn giải quyết, hãy ghi lại để sử dụng sau này.<br><br>
            <b>Bước 2: Bốc bài</b><br><br>
            <b>•</b> Tập trung vào câu hỏi hoặc vấn đề bạn muốn giải quyết.<br>
            <b>•</b> Chọn số lượng lá bài phù hợp với câu hỏi hoặc vấn đề của bạn. Có thể là một lá bài, ba lá bài (trong việc sử dụng cơ sở của "Quá khư, Hiện tại, Tương lai"), hoặc bất kỳ số lượng nào bạn cảm thấy phù hợp.<br>
            <b>•</b> Khi bạn đã chọn số lượng lá bài, hãy nhấn nút "Bốc bài" để rút ngẫu nhiên từ bộ bài. Bạn có thể rút và xem các lá bài cho đến khi đủ số lượng mong muốn.<br><br>
            <b>Bước 3: Hiểu ý nghĩa</b><br><br>
            Khi lá bài Tarot xuất hiện, hãy dành thời gian để quan sát và suy nghĩ về hình ảnh, ký hiệu và ý nghĩa của nó. Lưu ý rằng mỗi lá bài có thể đại diện cho một khía cạnh khác nhau của cuộc sống và tình huống của bạn.<br><br>
            <b>Bước 4: Suy ngẫm và hành động</b><br><br>
            Sau khi đã hiểu ý nghĩa của lá bài, hãy suy ngẫm về cách thông điệp của nó áp dụng vào tình huống hoặc câu hỏi của bạn. Xem xét những hành động cụ thể bạn có thể thực hiện để đạt được mục tiêu hoặc giải quyết vấn đề của mình. Lưu ý rằng lá bài Tarot không phải là dự đoán tương lai tuyệt đối, mà thay vào đó là một công cụ hỗ trợ để bạn đưa ra quyết định và phát triển bản thân.<br><br>
            <b>Bước 5: Ghi chú và tự phân tích</b><br><br>
            Cuối cùng, hãy ghi lại lá bài bạn đã bốc và ý nghĩa của nó. Sử dụng ghi chú này để tự phân tích và theo dõi tiến trình của bạn trong việc hiểu biết về Tarot và bản thân.<br><br>
            <hr><br>
            Hy vọng rằng hướng dẫn trên sẽ giúp bạn có một trải nghiệm xem bài Tarot thú vị và bổ ích trên trang web của mình! Nếu có bất kỳ câu hỏi nào, đừng ngần ngại liên hệ với mình thông qua <a href="mailto:hoaphamduc2399@gmail.com">Email</a>. Chúc bạn có những phút giây tuyệt vời với Tarot!
        </span>
    </div>
    <div class="result" id="result">
        <span class="name" id="name"></span>
        <img class="img" id="img">
        <span class="describe" id="describe"></span>
        <span id="how-to-read"></span>
        <span class="meaning" id="meaning"></span>
    </div>
    <div id="donate"></div>
    <div id="donateInfo"></div>
</body>

<!-- sakura shader -->
<script id="sakura_point_vsh" type="x-shader/x_vertex">
uniform mat4 uProjection;
uniform mat4 uModelview;
uniform vec3 uResolution;
uniform vec3 uOffset;
uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius
uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start

attribute vec3 aPosition;
attribute vec3 aEuler;
attribute vec2 aMisc; //x:size, y:fade

varying vec3 pposition;
varying float psize;
varying float palpha;
varying float pdist;

//varying mat3 rotMat;
varying vec3 normX;
varying vec3 normY;
varying vec3 normZ;
varying vec3 normal;

varying float diffuse;
varying float specular;
varying float rstop;
varying float distancefade;

void main(void) {
    // Projection is based on vertical angle
    vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);
    gl_Position = uProjection * pos;
    gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;
    
    pposition = pos.xyz;
    psize = aMisc.x;
    pdist = length(pos.xyz);
    palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);
    
    vec3 elrsn = sin(aEuler);
    vec3 elrcs = cos(aEuler);
    mat3 rotx = mat3(
        1.0, 0.0, 0.0,
        0.0, elrcs.x, elrsn.x,
        0.0, -elrsn.x, elrcs.x
    );
    mat3 roty = mat3(
        elrcs.y, 0.0, -elrsn.y,
        0.0, 1.0, 0.0,
        elrsn.y, 0.0, elrcs.y
    );
    mat3 rotz = mat3(
        elrcs.z, elrsn.z, 0.0, 
        -elrsn.z, elrcs.z, 0.0,
        0.0, 0.0, 1.0
    );
    mat3 rotmat = rotx * roty * rotz;
    normal = rotmat[2];
    
    mat3 trrotm = mat3(
        rotmat[0][0], rotmat[1][0], rotmat[2][0],
        rotmat[0][1], rotmat[1][1], rotmat[2][1],
        rotmat[0][2], rotmat[1][2], rotmat[2][2]
    );
    normX = trrotm[0];
    normY = trrotm[1];
    normZ = trrotm[2];
    
    const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);
    
    float tmpdfs = dot(lit, normal);
    if(tmpdfs < 0.0) {
        normal = -normal;
        tmpdfs = dot(lit, normal);
    }
    diffuse = 0.4 + tmpdfs;
    
    vec3 eyev = normalize(-pos.xyz);
    if(dot(eyev, normal) > 0.0) {
        vec3 hv = normalize(eyev + lit);
        specular = pow(max(dot(hv, normal), 0.0), 20.0);
    }
    else {
        specular = 0.0;
    }
    
    rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);
    rstop = pow(rstop, 0.5);
    //-0.69315 = ln(0.5)
    distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));
}
</script>
<script id="sakura_point_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif

uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius
uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start

const vec3 fadeCol = vec3(0.08, 0.03, 0.06);

varying vec3 pposition;
varying float psize;
varying float palpha;
varying float pdist;

//varying mat3 rotMat;
varying vec3 normX;
varying vec3 normY;
varying vec3 normZ;
varying vec3 normal;

varying float diffuse;
varying float specular;
varying float rstop;
varying float distancefade;

float ellipse(vec2 p, vec2 o, vec2 r) {
    vec2 lp = (p - o) / r;
    return length(lp) - 1.0;
}

void main(void) {
    vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;
    vec3 d = vec3(0.0, 0.0, -1.0);
    float nd = normZ.z; //dot(-normZ, d);
    if(abs(nd) < 0.0001) discard;
    
    float np = dot(normZ, p);
    vec3 tp = p + d * np / nd;
    vec2 coord = vec2(dot(normX, tp), dot(normY, tp));
    
    //angle = 15 degree
    const float flwrsn = 0.258819045102521;
    const float flwrcs = 0.965925826289068;
    mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);
    vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;
    
    float r;
    if(flwrp.x < 0.0) {
        r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);
    }
    else {
        r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);
    }
    
    if(r > rstop) discard;
    
    vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);
    float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));
    col *= vec3(1.0, grady, grady);
    col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));
    col = col * diffuse + specular;
    
    col = mix(fadeCol, col, distancefade);
    
    float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;
    alpha = smoothstep(0.0, 1.0, alpha) * palpha;
    
    gl_FragColor = vec4(col * 0.5, alpha);
}
</script>
<!-- effects -->
<script id="fx_common_vsh" type="x-shader/x_vertex">
uniform vec3 uResolution;
attribute vec2 aPosition;

varying vec2 texCoord;
varying vec2 screenCoord;

void main(void) {
    gl_Position = vec4(aPosition, 0.0, 1.0);
    texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
    screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
}
</script>
<script id="bg_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif

uniform vec2 uTimes;

varying vec2 texCoord;
varying vec2 screenCoord;

void main(void) {
    vec3 col;
    float c;
    vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);
    c = exp(-pow(length(tmpv) * 1.8, 2.0));
    col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);
    gl_FragColor = vec4(col * 0.5, 1.0);
}
</script>
<script id="fx_brightbuf_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif
uniform sampler2D uSrc;
uniform vec2 uDelta;

varying vec2 texCoord;
varying vec2 screenCoord;

void main(void) {
    vec4 col = texture2D(uSrc, texCoord);
    gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);
}
</script>
<script id="fx_dirblur_r4_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif
uniform sampler2D uSrc;
uniform vec2 uDelta;
uniform vec4 uBlurDir; //dir(x, y), stride(z, w)

varying vec2 texCoord;
varying vec2 screenCoord;

void main(void) {
    vec4 col = texture2D(uSrc, texCoord);
    col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);
    col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);
    col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);
    col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);
    gl_FragColor = col / 5.0;
}
</script>
<!-- effect fragment shader template -->
<script id="fx_common_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif
uniform sampler2D uSrc;
uniform vec2 uDelta;

varying vec2 texCoord;
varying vec2 screenCoord;

void main(void) {
    gl_FragColor = texture2D(uSrc, texCoord);
}
</script>
<!-- post processing -->
<script id="pp_final_vsh" type="x-shader/x_vertex">
uniform vec3 uResolution;
attribute vec2 aPosition;
varying vec2 texCoord;
varying vec2 screenCoord;
void main(void) {
    gl_Position = vec4(aPosition, 0.0, 1.0);
    texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
    screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
}
</script>
<script id="pp_final_fsh" type="x-shader/x_fragment">
#ifdef GL_ES
//precision mediump float;
precision highp float;
#endif
uniform sampler2D uSrc;
uniform sampler2D uBloom;
uniform vec2 uDelta;
varying vec2 texCoord;
varying vec2 screenCoord;
void main(void) {
    vec4 srccol = texture2D(uSrc, texCoord) * 2.0;
    vec4 bloomcol = texture2D(uBloom, texCoord);
    vec4 col;
    col = srccol + bloomcol * (vec4(1.0) + srccol);
    col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);
    col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)
    
    gl_FragColor = vec4(col.rgb, 1.0);
    gl_FragColor.a = 1.0;
}
</script>
<script src="js/script.js"></script>
<script src="data/cards-data.js"></script>
</html>